---
layout: single
title: "8주차 회고"
categories: "Bootcamp"
---

# [커널아카데미] 백엔드 개발 부트캠프 - 8주차 회고

## | 지난 한 주를 되돌아 보면서

데이터베이스 관련 과정이 끝났고, 아직 SQL 튜닝 책을 읽고 있다.

### | 스터디 요약 ###

#### Between의 성능을 향상시키기
운영환경에서 인덱스 컬럼 순서를 쉽게 바꾸기 어렵기 때문에, Between 조건을 IN-List로 바꾸면 성능이 향상될 수 있다.
단, 이는 인덱스 스캔 시 읽히는 레코드(값)들이 물리적으로 분산되어 있을 때 효과적이다.

#### 예제

```sql
where 인터넷매물 in ('1', '2', '3')
and 아파트시세코드 = ~
and 평형 = ~
and 평형타입 = ~

INDEX (아파트시세코드 + 평형 + 평형타입 + 인터넷매물)

-- 위와 같은 조건절에 인덱스 일 경우, 아래와 같은 상황이 만들어진다.
INLIST INERATOR 발동. IN 연산 개수만큼 실행 -> 총 3번

where 인터넷매물 = 1
and 아파트시세코드 = ~
and 평형 = ~
and 평형타입 = ~
union all
where 인터넷매물 = 2
and 아파트시세코드 = ~
and 평형 = ~
and 평형타입 = ~
union all
where 인터넷매물 = 3
and 아파트시세코드 = ~
and 평형 = ~
and 평형타입 = ~
```

하지만 IN-LIST 항목 개수가 많아지면 성능 저하가 발생할 수 있다. 이는 옵티마이저가 IN-LIST의 각 항목을 개별 
조건으로 분리하여 각각의 UNION ALL 브랜치를 생성하게 되는데, 브랜치 수가 많아질수록 실행 계획이 복잡해지고, 
CPU 사용량이 증가하며, 최종 결과를 합치는 비용도 커지기 때문이다. <br>

위와 같은 문제에 INDEX SKIP SCAN을 사용할 수 있다. 레코드들이 물리적으로 분산되어 있다면 위 힌트를 통해 INDEX
SKIP SCAN을 사용하면 쿼리 속도가 빨라진다. 이는 IN-LIST 방식과 거의 동일한 속도를 보인다. <br>

```sql
/*+ INDEX_SS(table index_name) */
```